## ⚡️ 동작 흐름 상세: 스파이크 하나가 만들어내는 연쇄 작용

`spike_in` 포트로 단일 스파이크가 입력되었을 때, 시스템 내부에서 일어나는 모든 연쇄 반응을 시간 순서대로 상세히 기술합니다.

---

### 1. 신호 전파 과정 (Forward Propagation)

입력된 스파이크가 네트워크를 통해 전파되고 출력으로 이어지는 핵심 경로입니다.

#### 1단계: 이벤트 감지 및 시스템 활성화
-   **`[입력]`** 외부에서 특정 뉴런(예: `i`번 뉴런)의 `spike_in[i]`에 1클록 동안 펄스가 인가됩니다.
-   **`[동작] power_manager`**:
    -   `|spike_in` (OR 리덕션)을 통해 하나 이상의 스파이크 입력을 즉시 감지합니다.
    -   **`core_en`**과 **`plasticity_en`** 신호를 `1`로 만들어, 잠자고 있던 **뉴런 코어**와 **가소성(학습) 로직**에 클럭을 공급하며 깨웁니다. 이것이 '이벤트 기반' 동작의 시작점입니다.
    -   내부 플래그인 `tail_active`를 `1`로 설정합니다. 이는 입력 스파이크가 멈춘 후에도 뉴런 내부의 전위 감쇠 활동이 완전히 끝날 때까지 코어를 계속 활성화 상태로 유지하기 위함입니다.

#### 2단계: 시냅스 정보 조회 및 펄스 생성
-   **`[동작] dynamic_synapse_processor_stream`**:
    -   `en=1`이 되면서 활성화됩니다. `ffs(find first set)` 로직을 통해 스파이크가 발생한 `i`번 뉴런의 인덱스(`pre`)를 식별합니다.
    -   **메모리 요청**: `weight_ram`에게 `rd_start=1` 펄스와 함께 `rd_pre=i` 주소를 보내, `i`번 뉴런의 '연결 목록'을 요청합니다.
    -   **스트림 수신**: `weight_ram`은 `i`번 뉴런과 연결된 모든 뉴런(`post`)의 정보(인덱스 `rd_post`, 가중치 `rd_weight`)를 `rd_valid` 신호와 함께 순차적으로(Stream) 보내줍니다. 프로세서는 `rd_next`를 통해 다음 데이터를 계속 요청하며, `rd_last` 신호가 올 때까지 이 과정을 반복합니다.
    -   **펄스 강도 계산**: 스트림으로 데이터를 받는 즉시, 각 연결에 대한 최종 펄스 강도를 계산합니다.
        -   `펄스 강도 = rd_weight * (u[i] * x[i])`
        -   이 계산은 `weight_ram`에 저장된 **정적 가중치**와, `i`번 뉴런의 현재 동적 상태(**단기 가소성 변수 u, x**)를 함께 반영합니다.
    -   **펄스 발송**: 계산된 강도를 `i`번 뉴런의 `inhib_flag`에 따라 `g_exc_pulse[rd_post]` 또는 `g_inh_pulse[rd_post]` 버스에 1클록 펄스로 출력합니다. 이 펄스는 이제 `post` 뉴런으로 전달될 '자극'입니다.

#### 3단계: 뉴런 상태 업데이트 및 발화
-   **`[동작] cortical_neuron_core_tm`**:
    -   이 모듈은 항상 0번부터 `N-1`번 뉴런까지 순서대로 상태를 계산하는 **시분할(Time-Multiplexing)** 방식으로 동작합니다.
    -   자신의 계산 차례가 된 `post` 뉴런은 `g_exc_pulse` 또는 `g_inh_pulse` 버스에 실린 값을 입력으로 받습니다.
    -   **상태 업데이트**: Izhikevich 모델의 미분 방정식에 따라, 입력된 펄스를 반영하여 자신의 내부 상태 변수인 **막 전위(`v`)**와 **회복 변수(`u`)**를 업데이트합니다.
    -   **발화 조건 확인**: 업데이트된 막 전위 `v`가 임계 전압 `V_PEAK`을 넘었는지 확인합니다.
    -   **`[출력]`** 발화 조건을 만족하면,
        -   `v`를 리셋 전위 `C_BASE`로, `u`를 `u+D`로 업데이트합니다.
        -   해당 뉴런의 `spike_out[post]` 비트에 1클록 펄스를 생성하여 외부로 출력합니다. 이 출력 스파이크는 다시 다른 뉴런의 `spike_in`이 되어 연쇄 반응을 일으킬 수 있습니다.

---

### 2. 학습 메커니즘 (Learning via Plasticity)

신호 전파와 **동시에** 일어나는 과정으로, 스파이크들의 타이밍 관계를 분석하여 네트워크의 '기억'인 시냅스 가중치를 수정합니다.

#### 1단계: 학습 이벤트 감지 및 후보 탐색
-   **`[동작] state_dependent_plasticity`**:
    -   `plasticity_en=1`로 활성화된 상태에서 `spike_in`과 `spike_out` 버스를 지속적으로 감시합니다.
    -   **타이밍 기록**: 모든 뉴런에 대해 마지막으로 스파이크가 발생한 시간을 `in_hist`, `out_hist` 배열에 계속 기록합니다. (정확히는 스파이크 후 경과 시간)
    -   **후보 탐색 (SCAN 상태)**: 스파이크가 감지되면, FSM(유한 상태 머신)이 `IDLE`에서 `SCAN` 상태로 전환되어 인과관계가 있는 뉴런 쌍을 탐색합니다.
        -   **LTP 후보 (연관성 강화)**: `spike_in[pre]`가 발생하면, "pre 뉴런이 자극받기 **직전에** 발화(`spike_out`)한 `post` 뉴런이 있는가?"를 모든 뉴런에 대해 탐색합니다. (`out_hist[post] > in_hist[pre]`)
        -   **LTD 후보 (연관성 약화)**: `spike_out[post]`가 발생하면, "post 뉴런이 발화하기 **직전에** 자극(`spike_in`)을 준 `pre` 뉴런이 있는가?"를 탐색합니다. (`in_hist[pre] > out_hist[post]`)

#### 2단계: 현재 가중치 정보 조회
-   **`[동작] state_dependent_plasticity`**:
    -   탐색 결과, 인과관계가 의심되는 뉴런 쌍(`pre`, `post`)을 찾으면, FSM은 `READ` 상태로 전환됩니다.
    -   **`[요청]`** `weight_ram`에 `rr_en=1` 신호와 함께 `rr_pre`와 `rr_post` 주소를 보내, 두 뉴런 사이의 현재 연결 가중치(`rr_weight`)를 '임의 읽기(Random Read)' 방식으로 요청합니다.

#### 3단계: 상태 의존적 가중치 변화량 결정
-   **`[동작] state_dependent_plasticity`**:
    -   `weight_ram`으로부터 `rr_valid` 신호와 함께 `rr_weight` 값을 받으면, 가중치를 얼마나 변화시킬지(`step`)를 결정합니다. 이 단계가 '상태 의존적' 학습의 핵심입니다.
    -   **판단 계층**:
        1.  **최우선: 뉴로모듈레이션 (`neuromod_signal`)**: 이 '보상' 신호가 `1`이면, 다른 모든 조건을 무시하고 가장 큰 폭(`+3`)으로 가중치를 강화합니다.
        2.  **차선: 네트워크 상태 (`network_state`)**: 보상 신호가 없다면, `network_state_monitor`가 알려준 전체 네트워크의 '분위기'를 참고합니다.
            -   **`LOW` (저활성)**: "사소한 이벤트군." → 변화 없음 (`step=0`).
            -   **`MID` (중간 활성)**: "의미 있는 인과관계야." → 일반적인 STDP 규칙에 따라 가중치를 변경 (`step=1`).
            -   **`HIGH` (과활성)**: "네트워크가 너무 흥분했어. 안정시켜야 해." → 오히려 가중치를 감소시켜 과열을 막습니다 (`step=-1`). (항상성 가소성)
    -   **새 가중치 계산**: `new_w = rr_weight +/- step` 공식을 통해 새로운 가중치를 계산합니다.

#### 4단계: 메모리 업데이트
-   **`[동작] state_dependent_plasticity`**:
    -   FSM이 `WRITE` 상태로 전환됩니다.
    -   **`[요청]`** `weight_ram`에 `w_en=1` 신호와 함께, 업데이트할 주소(`w_pre_idx`, `w_post_idx`)와 최종 데이터(`w_data`)를 전송하여 메모리의 값을 영구적으로 수정합니다.
    -   모든 과정이 끝나면 FSM은 다시 `IDLE` 상태로 돌아가 다음 학습 이벤트를 기다립니다.

이러한 정교한 흐름을 통해, 시스템은 단순히 신호를 전달하는 것을 넘어 주변 상황과 과거의 경험을 바탕으로 스스로를 계속해서 개선해 나갑니다.